---
layout: single
title: "[커서기반페이징] 3.커서기반페이징 API Request/Response의 BestPractice를 찾아서"
categories: "paging"
tag: ["api","refactoring","cursor-based-paging"]
toc: true
---

뭐든지 잘 만드는게 중요하니까 리서치해보는 Best Practice 시간.

# 시리즈

[1.커서기반페이징이란?](https://cogito1016.github.io/paging/PagingBasedOnCursor/)

[2.Base64인코딩된 토큰을 사용한 API 통신](https://cogito1016.github.io/paging/1.Base64Encoding/)

[3.커서기반페이징 API Request/Response의 BestPractice를 찾아서](https://cogito1016.github.io/paging/2.CursorPagingBestPractice/)



---

# 서론(+잡담)

뭐든 이론을 살피고 난 후 POC(개념실증)을 만들었다고 끝나는것이 아니라고 생각한다.



나만 이해갔다고 해서 출시를 해버리면 

시간이 흐른 뒤, 다른 개발자들이 살펴볼때 

'얘는 왜 이렇게 했지..?'라는 의문을 가져버린다면.. 

참 여러모로 골치아파진다. (부끄럽기도하고..)



따라서 이론 구현의 모범사례나 관례가 있다면 따르는것이 좋다는 개인적인 의견에서 비롯한! 

**커서기반페이징 API에서 사용되는 요청/응답 데이터 형식의 모범사례 찾기** 시간을 가져볼까 한다.



# 1.현황

일단 현황부터 정리해보자.

## 1.1.Request

- cursor( "idx" + "," + "time" 형식을 base64 인코딩 한)
- limit

## 1.2.Response

- data (cursor와 limit 범위에 해당하는 데이터리스트)
- cursor( "idx" + "," + "time" 형식을 base64 인코딩 한)



# 2.주요개념

- 커서는 데이터리스트에서 특정 항목을 표시하는 임의의 문자열을 가르킨다
- 커서는 항상 그 항목을 가르키지만, 항목이 삭제되면 무효화된다.
  - 따라서 커서가 계속 유효할것이라고 가정하지 말아야 한다.

# 3.커서 응답데이터 포멧

**Facebook API를 벤치마크했습니다.**

```json
"paging": {
  "cursors": {
    "after": "MTAxNTExOTQ1MjAwNzI5NDE=",
    "before": "NDMyNzQyODI3OTQw"
  },
  "previous": "https://graph.facebook.com/{your-user-id}/albums?limit=25&before=NDMyNzQyODI3OTQw"
  "next": "https://graph.facebook.com/{your-user-id}/albums?limit=25&after=MTAxNTExOTQ1MjAwNzI5NDE="
}
```

- before

  - 반환된 데이터 페이지의 시작을 가르키는 커서

- after

  - 반환된 데이터 페이지의 끝을 가르키는 커서

- limit

  - 반환될 수 있는 최대 개체 수

- next

  - 데이터의 다음 페이지를 반환하는 엔드포인트
  - 이 데이터가 포함되어있지 않으면, 현재 페이지가 마지막 페이지임을 나타냄

- previous

  - 데이터의 이전 페이지를 반환하는 엔드포인트
  - 이 데이터가 포함되어있지 않으면, 현재 페이지가 첫번째 페이지임을 나타냄




# 4.결과 

- Cursor을 반환하지만, 이것도 결국 Paging기법 중 하나이므로 Paging으로 감싼다.
- Cursor에는 After과 Before을 추가하여, 데이터의 시작과 끝 정보를 제공한다.
  - 이것으로 현재페이지가 첫페이지인지, 마지막페이지인지의 정보를 제공할 수 있다.
- Next와 Previous를 제공하여 클라이언트의 API사용 편의성을 높인다.
