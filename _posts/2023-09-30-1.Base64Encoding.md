---
layout: single
title: "[커서기반페이징] 2.Base64인코딩된 토큰을 사용한 API 통신"
categories: "paging"
tag: ["api","refactoring","encoding","[series]cursor-based-paging"]
toc: true
---

한번쯤은 봤었던 Base64, 이제 제대로 들여다보자.

# 시리즈

[1.커서기반페이징이란?](https://cogito1016.github.io/paging/PagingBasedOnCursor/)

[2.Base64인코딩된 토큰을 사용한 API 통신](https://cogito1016.github.io/paging/1.Base64Encoding/)

[3.커서기반페이징 API Request/Response의 BestPractice를 찾아서](https://cogito1016.github.io/paging/2.CursorPagingBestPractice/)



---

# 1.Base64 파헤치기

## 1.1.왜 Base64인코딩으로 통신을할까?

[1.커서기반페이징이란?](https://cogito1016.github.io/paging/PagingBasedOnCursor/) 편의 마지막에 언급했던 것 처럼,

- API 클라이언트의 조작방지
- 신뢰성 보장

위의 두 가지를 충족시키기 위해 Base64인코딩을 한다.



## 1.2.Base64란?

대표적인 이유는 위에 서술해놓았지만, 

좀 더 자세히 들여다보도록 한다.



Base64인코딩이란 바이너리 데이터를 아스키문자열로 변환하는 방법이다.

**왜 변환해야할까?**

1. 문자열 호환성 보장
2. 데이터 무결성 유지
   1. 데이터가 전송중에 손상되지 않도록 방지
3. 가독성 향상
   1. 바이너리 데이터는 사람이 읽을 수 없으므로 텍스트에디터에 제대로 표기되지 않음
4. URL안정성 확보
   1. URL은 일반적으로 아스키문자만을 포함할 수 있다.
      바이너리 데이터나 특수문자를 URL에 포함시키려면 Base64인코딩을 사용하여 이를 안전한 형식으로 표현할 수 있다.
5. 패딩
   1. '='문자를 사용하여 출력을 패딩하여 길이를 조정한다.
      이렇게함으로서, 데이터의 길이가 특정 길이의 배수가 아닐 경우에도 처리할 수 있다.



대체적으로 살펴볼때,

**보안보다는 안전성을 위한 방법**이라는것을 알 수 있다.



## 1.3.Base64예시

### 1.3.1.데이터무결성

이메일시스템은 일반적으로 텍스트만 처리할 수 있지만 첨부파일은 바이너리 데이터이다. 이메일시스템에 첨부파일을 안전하게 전송하려면 바이너리데이터를 텍스트형식으로 변화해야한다.



이 때,

1. 첨부파일을 Base64로 인코딩하여 아스키문자열로 변환
2. 이메일본문에 안전하게 포함
3. 수신자는 Base64로 디코딩하여 원래의 바이너리로 변환
4. 이 과정에서 데이터의 변경, 손상이 일어나지않음



### 1.3.2.패딩은 무슨의미?

**1.2 > ''왜 변환해야할까?' > 5번 > 패딩** 은 무엇을 의미할까?

Base64인코딩은 출력 문자열의 길이가 항상 4의배수가 되도록 패딩을 사용한다. 이는 '='문자를 사용하여 수행한다.

"AB"라는 문자열을 Base64로 인코딩하려고 한다면,

1. "AB"의 아스키값은 '65 66'이다
2. 이 값들을 이진수로 변환하면 01000001 01000010 이다
3. 이것을 연결하여 '01000001 01000010'을 얻는다
4. 이진데이터를 6비트씩 묶어 '010000 010100 0010'을 얻는다
5. 이진수 '010000'은 16 '010100'은 20 '0010'은 2에 해당한다
6. Base64에서 이값들은 각각 'Q' 'U' 'C'에 해당한다
7. 그러나 Base64 인코딩된 문자열의 길이는 항상 4의배수여야 하므로 결과는 QU C=가 된다

이때 사용하는 '='가 패딩에 사용되는 문자이다.



#### 1.3.2.1.왜 패딩을 사용하면서까지 4의배수로 맞추는가?

디코딩 프로세스에서 입력 데이터의 실제 길이를 찾기위함이다.

# 2.Base64 결론

- 보안성보다는 전달하는 데이터의 무결성을 위해 사용한다.
- 따라서 Base64는 별도의 암호프로토콜이 아니다.
- Base64 인코딩/디코딩을 위한 간단한 절차들이 있고, 이를 통해 쉽게 인코딩 디코딩이 가능하다.
  - 문자를 아스키로변경 -> 2진수로변경 -> 6비트로 분활 -> 비트에해당하는 문자로 변경 -> 이때, 4의배수와 맞지않으면 패딩문자 '='를 삽입하여 길이를조정

# 3.적용하기

자, 그럼이제 커서기반페이징의 통신데이터를 Base64로 전달하자.



## 3.1. Response

- Before

```json
"cursor": {
            "time": "2022-03-17 13:05:40",
            "idx": "3881443"
        }
```

- After

```json
"cursor": "Mzg4MTQ0MywyMDIyLTAzLTE3IDEzOjA1OjQw"
```



idx와 time을 ','(쉼표)문자로 나눈 문자열을 Base64인코딩하여 응답했다.

그럼 time과 idx을 Request Param으로 API를 호출하지않고,

위의 cursor을 보내면된다.



그럼 API서버는 다음과같은 절차를 밟으면 된다.

1. Mzg4MTQ0MywyMDIyLTAzLTE3IDEzOjA1OjQw
   - Bas64로 인코딩된 토큰을 최초에 전달받을 때

2. 3881443,2022-03-17 13:05:40
   - 토큰을 Base64디코드를 했을 때
3. 

```
 Array
(
    [0] => 3881443
    [1] => 2022-03-17 13:05:40
)
```

- 디코드된 데이터를 ','로 spslit해서 사용	



안전하게 idx와 time을 받아 쿼리로 사용할 수 있게 되었다.



자 그럼 이제, 커서기반페이징에 사용할 Respose/Request Data에 대한 

Best Practice를 알아보고자한다.



**다음편에 계속**
